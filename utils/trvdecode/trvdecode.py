#!/usr/bin/env python3

"""
Copyright [2016] [Mark Hill]
          [2017] [Deniz Erbilgin]

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

This program:
    reads in log files in OpenTRV frame format and decodes
    requires a csv file containing decryption keys
"""

import csv
import sys
import os
import binascii
import aesgcm
import argparse
import logging


def read_in_decryption_keys(keyfile):
    # node id, decryption key
    keys = []
    encoded_data = csv.reader(keyfile, delimiter=',')
    for item in encoded_data:
        if 2 <= len(item):
            keys.append(item)
    return keys


def decrypt_item(hexstring, keys):
    short_node_length = int(hexstring[7], 16)
    log.debug("short node length: " + repr(short_node_length))
    short_node_id = hexstring[
        9:(11 + 3 * short_node_length - 2)].replace(" ", "")
    log.debug("decoded short node id: \"" + short_node_id + "\"")

    # look through keys, find the full node id for the short node id
    full_node_id_list = [key for key in keys.keys() if (
        key.replace(' ', '').lower()[:2 * short_node_length] == short_node_id
    )]
    if len(full_node_id_list) > 1:
        log.error("found more than node id => key: " + repr(full_node_id_list))
        sys.exit("duplicate keys found for node: " + short_node_id)
    elif len(full_node_id_list) == 0:
        # error - couldn't find the node id in the supplied list
        return '***error: node id ' + short_node_id + ' not found***'
    else:
        full_node_id = full_node_id_list.pop()  # only 1 item in list
    log.debug("full_node_id: " + full_node_id)

    node_key = keys[full_node_id][4:]
    node_id_squashed = full_node_id.replace(' ', '').lower()
    key_squashed = node_key.replace(' ', '').lower()
    hex2 = binascii.unhexlify(hexstring.replace(" ", ""))

    plain_text = aesgcm.decrypt_message(hex2, key_squashed, node_id_squashed[0:12])

    return plain_text

parser = argparse.ArgumentParser(description='Decode OpenTRV radio frames, V1.1 Requires a keyfile in the same format generated by the production programming rig.')
parser.add_argument('--verbose', '-v', action='store_true', help='verbose output')
parser.add_argument('--infile',  type=argparse.FileType('rt', encoding="latin-1"), default=sys.stdin, help='input file, default is stdin')
parser.add_argument('--outfile', type=argparse.FileType('w', encoding="latin-1"), default=sys.stdout, help='output file, default is stdout')
parser.add_argument('--keyfile', type=argparse.FileType('rt', encoding="latin-1"), default=open('keys.csv', 'r', -1, encoding="latin-1"), help='default keys.csv')
args = parser.parse_args()
args_dict = vars(args)
verbose = args_dict['verbose']
if verbose:
    log_level = logging.DEBUG
else:
    log_level = logging.WARNING
logging.basicConfig(level=log_level, format='%(asctime)s %(filename)15s:%(lineno)3s %(funcName)20s() %(levelname)-8s %(message)s')
log = logging.getLogger('root')
log.debug("verbose mode, debug logging selected")

log.debug("args:" + repr(args))

full_key_info = read_in_decryption_keys(args_dict['keyfile'])
log.debug(str(len(full_key_info)) + " keys read from " + repr(args_dict['keyfile']))

key_map = {item[0]: item[1] for item in full_key_info}

node_map = {item[2]: item[1] for item in full_key_info}

log.debug(str(len(key_map)) + " items in key_map")
log.debug(str(len(node_map)) + " items in node_map")

log.debug("opening infile: " + repr(args_dict['infile']))

# get a line, process, write it out
data_in = csv.reader(args_dict['infile'], delimiter=',')
log.debug("iterator: " + repr(data_in))


def c_encode(ch):
    if ch < 31 or ch >= 127:
        return '\\x{0:02x}'.format(ch)
    else:
        return chr(ch)

csv_writer = csv.writer(args_dict['outfile'], delimiter=',', quotechar="'", quoting=csv.QUOTE_NONNUMERIC)
for line in data_in:
    # process
    (timestamp, ipaddress, hexstring) = line
    log.debug("timestamp: {} ipaddress: {} hexstring with {} chars: {}".format(
        timestamp,
        ipaddress,
        len(hexstring),
        hexstring))
    decrypted = decrypt_item(hexstring, node_map)
    # write out
    if type(decrypted) == bytes:
        if (ord(decrypted[-1:])) < 32:  # meaning there is padding
            decrypted = decrypted[:-1]
        while (ord(decrypted[-1:])) == 0:
            decrypted = decrypted[:-1]
        line.append(decrypted)  # python style
        c_decrypted = [c_encode(ch) for ch in decrypted]
        line.append(''.join(c_decrypted))  # C style
    else:
        line.append("")
        line.append("")
    csv_writer.writerow(line)

    if str(decrypted).startswith('***error'):
        log.error("decrypted {}".format(str(decrypted)))
    else:
        log.debug("decrypted {}".format(str(decrypted)))

# carry forward a and mtime etc.
args_dict['outfile'].flush()
args_dict['outfile'].close()

if (args_dict['outfile'].name == '<stdout>') or (args_dict['infile'].name == '<stdin>'):
    pass
else:
    st = os.stat(args_dict['infile'].name)
    os.utime(args_dict['outfile'].name, (st.st_atime, st.st_mtime))



